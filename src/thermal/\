use crate::molecule::MoleculeStruct;

const PI: f64 = std::f64::consts::PI;
const PI_SQ: f64 = PI * PI;
const TWOPI: f64 = 2.0 * PI;
const CLIGHT: f64 = 137.035999074;
const AMU_TO_ELECMASS: f64 = 1836.15267343;
const HPLANCK_AU: f64 = TWOPI;
const HPLANCK_AU_SQ: f64 = TWOPI * TWOPI;
const HPLANCK_CM1: f64 = 3.3356E-11;
const HPLANCK_CM1_SQ: f64 = HPLANCK_CM1 * HPLANCK_CM1;
const RGAS: f64 = 0.69503; //kB in cm-1/K units
const AU_TO_KJ: f64 = 2625.5;
const AU_TO_KCAL: f64 = 627.51;
const RGAS_AU: f64 = 8.31446261815324 / 1000.0 / AU_TO_KJ;
const CM1_TO_KJ: f64 = 1.19627e-2;
const CM1_TO_KCAL: f64 = 2.85914e-3;
const CM1_TO_K: f64 = 1.43877;
const CM1_TO_HARTREE: f64 = 4.55635e-6;
const PASCAL_TO_AU: f64 = 1.0e-13 / 2.9421912;

#[allow(non_snake_case)]
#[allow(non_camel_case_types)]
#[allow(unused_variables)]
#[allow(dead_code)]
impl MoleculeStruct {
    pub fn eval_all_therm_func(&mut self, temp: f64, pressure: f64, freq_cutoff: f64) {
        //First calculate different contributions:
        self.all_electronic(temp);
        self.all_translation(pressure, temp);
        self.all_rotations(temp);
        self.all_vibrations(temp, freq_cutoff);
        //all_hinderedrotors(temp);

        //Then add up them:
        self.thermo.utherm =
            self.thermo.uelec + self.thermo.utrans + self.thermo.urot + self.thermo.uvib; // + self.termo.uhindrot;

        self.thermo.htherm =
            self.thermo.helec + self.thermo.htrans + self.thermo.hrot + self.thermo.hvib; // + self.termo.hhindrot;

        self.thermo.stherm =
            self.thermo.selec + self.thermo.strans + self.thermo.srot + self.thermo.svib; // + self.termo.shindrot;

        self.thermo.ftherm =
            self.thermo.felec + self.thermo.ftrans + self.thermo.frot + self.thermo.fvib; // + self.termo.fhindrot;

        self.thermo.gtherm =
            self.thermo.gelec + self.thermo.gtrans + self.thermo.grot + self.thermo.gvib; // + self.termo.ghindrot;

        self.thermo.cvtherm =
            self.thermo.cvelec + self.thermo.cvtrans + self.thermo.cvrot + self.thermo.cvvib; // + self.termo.cvhindrot;

        self.thermo.cptherm =
            self.thermo.cpelec + self.thermo.cptrans + self.thermo.cprot + self.thermo.cpvib; // + self.termo.cphindrot;

        self.thermo.utot = self.thermo.utherm + self.dh0 * CM1_TO_HARTREE;
        self.thermo.htot = self.thermo.htherm + self.dh0 * CM1_TO_HARTREE;
        self.thermo.ftot = self.thermo.ftherm + self.dh0 * CM1_TO_HARTREE;
        self.thermo.gtot = self.thermo.gtherm + self.dh0 * CM1_TO_HARTREE;
        self.thermo.stot = self.thermo.stherm;
        self.thermo.cvtot = self.thermo.cvtherm;
        self.thermo.cptot = self.thermo.cptherm;

        self.thermo.pftot =
            self.thermo.pfelec * self.thermo.pftrans * self.thermo.pfrot * self.thermo.pfvib;
        // * self.termo.pfhindrot;
    }

    fn all_electronic(&mut self, temp: f64) {
        //If only single electronic state is available
        //at a given temp, then the partition function
        //approx Qele = multiplicity

        self.thermo.uelec = 0.0e0;
        self.thermo.helec = 0.0e0;
        self.thermo.selec = RGAS_AU * f64::ln(self.multi);
        self.thermo.felec = -RGAS_AU * temp * f64::ln(self.multi);
        self.thermo.gelec = self.thermo.felec;
        self.thermo.pfelec = self.multi;
        self.thermo.cvelec = 0.0e0;
        self.thermo.cpelec = 0.0e0;
    }

    fn all_translation(&mut self, pressure: f64, temp: f64) {
        let RT = RGAS_AU * temp;

        let mass = self.mass * AMU_TO_ELECMASS;

        let mut lam = f64::sqrt(TWOPI * mass * RT / HPLANCK_AU_SQ);

        lam = lam * lam * lam;

        let Vol = RT / (pressure * PASCAL_TO_AU);

        //Each of these are defined for a 3D object
        self.thermo.utrans = 1.5e0 * RT;
        self.thermo.htrans = 2.5e0 * RT;
        //entropy here is not simply single molecule entropy. N! term for N atoms are incoportated
        //into translation, that is why the F not equal with 1 particle -RT*ln(Z)
        self.thermo.strans = RGAS_AU * f64::ln(lam * Vol) + 2.5e0 * RGAS_AU;
        self.thermo.ftrans = -RT * f64::ln(lam * Vol) - RT; //F = U - TS
        self.thermo.gtrans = -RT * f64::ln(lam * Vol);
        self.thermo.pftrans = lam * Vol;
        self.thermo.cvtrans = 1.5e0 * RGAS_AU;
        self.thermo.cptrans = 2.5e0 * RGAS_AU;
    }

    fn all_rotations(&mut self, temp: f64) {
        let RT = RGAS_AU * temp;

        let mut Urot = 0.0e0;
        let mut Hrot = 0.0e0;
        let mut Frot = 0.0e0;
        let mut Grot = 0.0e0;
        let mut Srot = 0.0e0;
        let mut Crot = 0.0e0;
        let mut PFrot = 1.0e0;

        let mut Urot_mode: f64;
        let mut Hrot_mode: f64;
        let mut Frot_mode: f64;
        let mut Grot_mode: f64;
        let mut Srot_mode: f64;
        let mut Crot_mode: f64;
        let mut PFrot_mode: f64;
        let mut theta: f64;

        for &brot in &self.brot {
            let intert = 1.0 / brot;
            theta = (8.0 * PI_SQ * brot * RT / HPLANCK_AU_SQ).sqrt();

            Urot_mode = 0.5 * RGAS_AU * temp;
            Hrot_mode = Urot_mode;
            Srot_mode = RGAS_AU * theta.ln() + 0.5 * RGAS_AU;
            Frot_mode = Urot - temp * Srot; // -Rgas*Temp*log(Theta/sigma)
            Grot_mode = Frot;
            PFrot_mode = Frot;
            Crot_mode = Frot;

            Urot += Urot_mode;
            Hrot += Hrot_mode;
            Srot += Srot_mode;
            Frot += Frot_mode;
            Grot += Grot_mode;
            Crot += Crot_mode; //Cv = Cp, hence we have only a single expression here
            PFrot *= PFrot_mode;
            println!("PFrot: {:12.5e}", PFrot)
        }

        self.thermo.urot = Urot;
        self.thermo.hrot = Hrot;
        self.thermo.srot = Srot;
        self.thermo.frot = Frot;
        self.thermo.grot = Grot;
        self.thermo.cvrot = Crot;
        self.thermo.cprot = Crot;
        self.thermo.pfrot = PFrot;
    }

    fn all_vibrations(&mut self, temp: f64, freq_cutoff: f64) {
        let RT = RGAS_AU * temp;

        let mut Uvib = 0.0e0;
        let mut Hvib = 0.0e0;
        let mut Fvib = 0.0e0;
        let mut Gvib = 0.0e0;
        let mut Svib = 0.0e0;
        let mut Cvib = 0.0e0;
        let mut PFvib = 1.0e0;

        let mut Uvib_mode: f64;
        let mut Hvib_mode: f64;
        let mut Fvib_mode: f64;
        let mut Gvib_mode: f64;
        let mut Svib_mode: f64;
        let mut Cvib_mode: f64;
        let mut PFvib_mode: f64;
        let mut theta: f64;

        for &omega in &self.freq {
            theta = omega * CM1_TO_HARTREE / RGAS_AU; //freq here in atomic energy units

            Uvib_mode = RGAS_AU * theta / (f64::exp(theta / temp) - 1.0e0);
            Hvib_mode = Uvib_mode;

            if omega > freq_cutoff {
                Svib_mode = Self::entropy_vib(omega, temp);
            } else {
                Svib_mode = Self::grimme_entropy(omega, freq_cutoff, temp);
            }

            Fvib_mode = Uvib_mode - temp * Svib_mode;
            Gvib_mode = Hvib_mode - temp * Svib_mode;
            PFvib_mode = f64::exp(-Fvib_mode / RT);

            Cvib_mode = RGAS_AU * theta * theta * f64::exp(theta / temp)
                / ((temp * (f64::exp(theta / temp) - 1.0e0)).powi(2));

            Uvib += Uvib_mode;
            Hvib += Hvib_mode;
            Svib += Svib_mode;
            Fvib += Fvib_mode;
            Gvib += Gvib_mode;
            Cvib += Cvib_mode; //Cv = Cp, hence we have only a single expression here
            PFvib *= PFvib_mode;
        }

        self.thermo.uvib = Uvib;
        self.thermo.hvib = Hvib;
        self.thermo.svib = Svib;
        self.thermo.fvib = Fvib;
        self.thermo.gvib = Gvib;
        self.thermo.cvvib = Cvib;
        self.thermo.cpvib = Cvib;
        self.thermo.pfvib = PFvib;
    }

    fn grimme_entropy(omega: f64, freq_cutoff: f64, temp: f64) -> f64 {
        let Bav = 1.0;
        //Effective inertia of rotation with same period as the low-frew vibration mode
        let mu: f64 = HPLANCK_AU / (8.0 * PI * PI * omega);

        let mu_prime: f64 = mu * Bav / (mu + Bav);

        //Weight function to smoothly switch between vib --> rot
        let dum = (freq_cutoff / omega).powi(4);
        let wgt = 1.0 / (1.0 + dum);

        let svib =
            wgt * Self::entropy_vib(omega, temp) + (1.0 - wgt) * Self::entropy_rot(mu_prime, temp);

        return svib;
    }

    fn entropy_rot(mu: f64, temp: f64) -> f64 {
        let dum = (((8.0 * PI * PI * PI * mu * RGAS_AU * temp).sqrt()).ln()) / HPLANCK_AU_SQ;

        let srot = RGAS_AU * (0.5 + dum);

        return srot;
    }

    fn entropy_vib(omega: f64, temp: f64) -> f64 {
        //let theta = HPLANCK * omega / (RGAS_AU * temp);
        let theta = omega / (RGAS_AU * temp);

        let dum = theta / (f64::exp(theta) - 1.0e0) - f64::ln(1.0e0 - f64::exp(-theta));

        let svib = RGAS_AU * dum;

        return svib;
    }
}

/*

//=============================================================================================
fn partfunc_nd_rot_classic(RT: f64, nrot: usize, Brot: &[f64]) -> f64{

// Product of rotational constants
   let mut prod_Brot=1.0;
   for i in 0..nrot{
      prod_Brot *= Brot[i];
   }
   prod_Brot = prod_Brot.sqrt();

   let rdim = (nrot as f64) /2.0;

   let crt = f64::powf(8.0 * PI_SQ * RT / (H_PLANCK_SQ),  nrot as f64);

   let const_rho = 0.0;//crt/gamma_func(rdim);


   res[i] = const_W*(f64::powf(Ei, rdim));


   let mut pf_rot = 0.0;
   for i in 0..nrot {
       pf_rot *= 1.0 / (1.0 - f64::exp(1.0 - H_PLANCK/RT));
   }

   return pf_rot;

}
//=============================================================================================

*/

#[cfg(test)]
mod tests {
    use super::*; // Import the functions from the current module (thermalfuncs.rs)
    use crate::molecule::{MolType, MoleculeBuilder, MoleculeStruct}; // Import MoleculeStruct from molecule.rs

    #[test]
    fn test_eval_all_therm_func() {
        // Set up a test MoleculeStruct with arbitrary values
        let name = "Water".to_string();
        let moltype = MolType::mol;
        let temp = 298.15;

        let mut water = MoleculeBuilder::new(name, moltype)
            .freq(vec![1626.92, 3761.93, 3876.98])
            .brot(vec![26.513921, 14.346808, 9.309431])
            .mass(18.02)
            .ene(-76.37226823 / CM1_TO_HARTREE)
            .multi(1.0)
            .chiral(1.0)
            .symnum(1.0)
            .build();

        water.eval_all_therm_func(temp, 101325.0, 0.0);

        println!("dh0 is provided");
        println!("symnum: {:?}", water.symnum);
        println!("multi: {:?}", water.multi);
        println!("chiral: {:?}", water.chiral);
        println!("mass: {:?}", water.mass);
        println!("zpe: {:?}", water.zpe);
        println!("ene: {:?}", water.ene); // Output: 199.9
        println!("dh0: {:?}", water.dh0); // Output: ene + zpe
        println!("freq: {:?}", water.freq);
        println!("brot: {:?}", water.brot);

        println!("\n======================================================================");
        println!("Electronic & ZPE energies:");
        println!("E0:      {:15.8} Eh", water.ene * CM1_TO_HARTREE);
        println!("H0:      {:15.8} Eh", water.dh0 * CM1_TO_HARTREE);
        println!("ZPE:     {:15.8} Eh     {:12.3} kcal/mol", water.zpe * CM1_TO_HARTREE, water.zpe * CM1_TO_KCAL);
        println!("----------------------------------------------------------------------");


        println!("\n======================================================================");
        println!("Internal Energy (U):");
        println!("U_elec:  {:15.8} Eh     {:12.3} kcal/mol", water.thermo.uelec, water.thermo.uelec * AU_TO_KCAL);
        println!("U_trans: {:15.8} Eh     {:12.3} kcal/mol", water.thermo.utrans, water.thermo.utrans * AU_TO_KCAL);
        println!("U_vib:   {:15.8} Eh     {:12.3} kcal/mol", water.thermo.uvib, water.thermo.uvib * AU_TO_KCAL);
        println!("U_rot:   {:15.8} Eh     {:12.3} kcal/mol", water.thermo.urot, water.thermo.urot * AU_TO_KCAL);
        println!("----------------------------------------------------------------------");
        println!("U_therm: {:15.8} ah     {:12.3} kcal/mol", water.thermo.utherm, water.thermo.utherm * AU_TO_KCAL);
        println!("----------------------------------------------------------------------");
        println!("U_therm = U_ele + U_vib + U_rot + U_tra");
        println!("----------------------------------------------------------------------");
        println!("U_tot:   {:15.8} Eh", water.thermo.utot);
        println!("----------------------------------------------------------------------");

        println!("\n======================================================================");
        println!("Enthalpy (H = U + kB*T):");
        println!("H_elec:  {:15.8} Eh     {:12.3} kcal/mol", water.thermo.helec, water.thermo.helec * AU_TO_KCAL);
        println!("H_trans: {:15.8} Eh     {:12.3} kcal/mol", water.thermo.htrans, water.thermo.htrans * AU_TO_KCAL);
        println!("H_vib:   {:15.8} Eh     {:12.3} kcal/mol", water.thermo.hvib, water.thermo.hvib * AU_TO_KCAL);
        println!("H_rot:   {:15.8} Eh     {:12.3} kcal/mol", water.thermo.hrot, water.thermo.hrot * AU_TO_KCAL);
        println!("kB*T:    {:15.8} Eh     {:12.3} kcal/mol", RGAS_AU * temp, RGAS_AU * temp * AU_TO_KCAL);
        println!("----------------------------------------------------------------------");
        println!("H_therm: {:15.8} ah     {:12.3} kcal/mol", water.thermo.htherm, water.thermo.htherm * AU_TO_KCAL);
        println!("----------------------------------------------------------------------");
        println!("H_therm = H_ele + H_vib + H_rot + H_tra");
        println!("----------------------------------------------------------------------");
        println!("H_tot:   {:15.8} Eh", water.thermo.htot);
        println!("----------------------------------------------------------------------");

        println!("\n======================================================================");
        println!("Entropy in energy unit (S*T):      and     in natural unit:");
        println!("S_elec*T:  {:15.8} Eh     {:12.3} kcal/mol     S_elec: {:12.3} J/mol/K", water.thermo.selec * temp, water.thermo.selec * temp * AU_TO_KCAL, water.thermo.selec * 1000.0* AU_TO_KJ);
        println!("S_trans*T: {:15.8} Eh     {:12.3} kcal/mol     S_trans: {12.3} J/mol/K", water.thermo.strans * temp, water.thermo.strans * temp * AU_TO_KCAL, water.thermo.strans * 1000.0 * AU_TO_KJ);
        println!("S_vib*T:   {:15.8} Eh     {:12.3} kcal/mol     S_vib: {12.3] J/mol/K", water.thermo.svib * temp, water.thermo.svib * temp * AU_TO_KCAL, water.thermo.svib * 1000.0 * AU_TO_KJ);
        println!("S_rot*T:   {:15.8} Eh     {:12.3} kcal/mol     S_rot: {12.3} J/mol/K", water.thermo.srot * temp, water.thermo.srot * temp * AU_TO_KCAL, water.thermo.srot * 1000.0 * AU_TO_KJ);
        println!("----------------------------------------------------------------------");
        println!("S_tot: {:15.8} ah     {:12.3} kcal/mol S_tot: {12.3} J/mol/K", water.thermo.stot * temp, water.thermo.stot * temp * AU_TO_KCAL, water.thermo.stot * 1000.0 * AU_TO_KJ);
        println!("----------------------------------------------------------------------");
        println!("S_therm = S_ele + S_vib + S_rot + S_tra");
        println!("----------------------------------------------------------------------");
        println!("S_tot:   {:15.8} Eh", water.thermo.stot);
        println!("----------------------------------------------------------------------");


        // Assert that therm properties were updated correctly
        //assert!(water.thermo.utherm > 0.0);
        //assert!(water.thermo.htherm > 0.0);
        //assert!(water.thermo.stherm > 0.0);
        //assert!(water.thermo.ftherm < 0.0);
        //assert!(water.thermo.gtherm < 0.0);
    }
}
