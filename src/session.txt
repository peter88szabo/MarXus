
• I checked src/barrierless/sacm/SPCoord.f90, src/barrierless/sacm/SPCoord.inp, and our Rust src/barrierless/sacm/spcoord.rs.

  What matches:

  - The center‑of‑mass math and distance/angle formulas in src/barrierless/sacm/spcoord.rs are the same as SPCoord.f90 (vector differences, norms, and angle via
    acos(dot/(qe*q2e)) in degrees).
  - For diatomic vs triatomic, we already branch on presence of fragment Z (same logic as NAt>2 in Fortran).

  Key differences:

  - SPCoord.f90 reads 1‑based atom indices from SPCoord.inp. Our Rust code expects 0‑based indices and doesn’t parse SPCoord.inp at all.
  - SPCoord.f90 asks for NAt interactively; the .inp file doesn’t contain that. In Rust we infer triatomic by whether fragment_z is present (OK, but requires a proper
    parser to set it).
  - SPCoord is not used anywhere in the thermal rate code or examples right now. The example uses the explicit QE = 4.058 from the input block, not a computed geometry.

  So if you want SPCoord‑based geometry to feed the model, we should:

  1. Add a small parser in src/barrierless/sacm/spcoord.rs (or a new file) to read SPCoord.inp and convert 1‑based indices to 0‑based.
  2. Wire that into whichever example or input path should provide QE/angle instead of hard‑coding it.

  If you want me to implement this parser + wire it in, tell me which workflow you want:

  1. SPCoord.inp as the source of QE/angle for examples (and replace the manual QE).
  2. Expose a helper that returns QE/angle, but keep examples manual.

  Also, if you have SPCoord.out from the Fortran run, share the expected qe/q2e/angle so I can confirm our output matches exactly.


› implement the SPCoord.inp inside the example (not as an externel input), then read it from there with a correct parser
