
      SUBROUTINE DCOUNT(K,AEMAX,LENGTH,NY,MROT,B)
      SUBROUTINE SCOUNT(NF,EPS,X,EMAX,LENGTH)
      SUBROUTINE COUNT(K,M)
      SUBROUTINE ETERAT(DMORSE,EZP,DEZ,ALBE,BE,A1,A2,J,ENULLJ)
      SUBROUTINE SPOL(ALBE,DMORSE)
      SUBROUTINE WCOUNT(KZP,NCE,EMAX,LENGTH,J,B1,B2,NVIB1,NVIB2,NY1,
      SUBROUTINE WLLA(AEMAX,LENGTH,J,B)
      SUBROUTINE WLSA(AEMAX,LENGTH,J,B)
      SUBROUTINE WLLL(NCE,AEMAX,LENGTH,JG,B1,B2)
      SUBROUTINE WLSL(NCE,AEMAX,LENGTH,JG,BST,BLI)
      SUBROUTINE WLSS(NCE,AEMAX,LENGTH,JG,B1,B2)
      SUBROUTINE RHOIRO(N,LENGTH)



c=================================================================
      SUBROUTINE DCOUNT(K,AEMAX,LENGTH,NY,MROT,B)
c=================================================================
c This subroutine calculates the density of states for an ensemble of 
c k harmonic vibrations and mrot free one-dimensional rotations. It
c constructs the input data required by the subroutine COUNT.
c The densities are contained in the array mrho.
c (In pure vibrational systems densities are smoothed.)
c********************************************************************
c k: number of vibrational degrees of freedom
c aemax: energy up to which the density is counted
c length: step size of counting
c ny: array of the frequencies
c mrot: number of rotational degrees of freedom
c b: array of the rotational constants
c********************************************************************
      DIMENSION B(10)
      COMMON/A/ MRHO(0:100005)
      COMMON/C/ MT(0:100005)
      COMMON/D/ MR(200)
      DOUBLE PRECISION DGAMMA,MRHO,MT
      REAL NY(100),LENGTH
      N=INT(AEMAX/LENGTH+.5)
      IF(MROT)1,1,2
    1 MT(0)=1.
      DO 5 I=1,N
    5 MT(I)=0.
      DO 3 I=1,K
    3 MR(I)=INT(NY(I)/LENGTH+.5)
      CALL COUNT(K,N)
c
c Smoothing of the densities in pure vibrational systems
c
      I=0
   50 J=0
   20 I=I+1
      IF(MT(I).GT.0..OR.I.EQ.N) GOTO 30
      J=J+1
      GOTO 20
   30 DO 40 IK=I-1,I-(J+1),-1
   40 MT(IK)=MT(I-(J+1))/(J+1)
      IF(I.LT.N) GOTO 50
      MT(N)=MT(N-1)
c
c End of smoothing
c
      DO 60 I=0,N
   60 MRHO(I)=MT(I)/LENGTH
      RETURN
    2 GD=MROT/2.0
      GDZ=GD+1.0
      PRODBI=1.
      DO 9 I=1,MROT
    9 PRODBI=PRODBI*SQRT(B(I))  
      CON=1.772454**MROT/(DGAMMA(DBLE(GDZ))*PRODBI)
      MT(0)=1.
      DO 6 I=1,N
      RIND=1.0*I*LENGTH
      RIN=RIND-LENGTH
    6 MT(I)=CON*(RIND**GD-RIN**GD)
      DO 8 I=1,K
    8 MR(I)=INT(NY(I)/LENGTH+.5)
      CALL COUNT(K,N)
      DO 7 I=0,N
    7 MRHO(I)=MT(I)/LENGTH
      RETURN
      END
      
      
c=================================================================      
      SUBROUTINE SCOUNT(NF,EPS,X,EMAX,LENGTH)
C**********************************************************************
C This subroutine calculates the number of open channels by convolution
C of Wdisapp(E,J) with the conserved degrees of freedom via the Beyer-
C Swinehart algorithm.
C NF: Number of the degrees of freedom,
C EPS(I): Energy quanta of the degrees of freedom,
C X(I): "Exponents" of the degrees of freedom.
C**********************************************************************
      REAL LENGTH
      DOUBLE PRECISION MT,MW
      DIMENSION EPS(110),X(110)
      COMMON/SCOUN/ MW(0:100005)
      COMMON/C/ MT(0:100005)
      COMMON/D/ MR(200)
      COMMON/SPOLL/NFG,EPSE(110),EPSP(110),XE(110),XP(110),
     *             EPSTS(110),XTS(110)
      N=INT(EMAX/LENGTH+.5)
      MT(0)=1.
      DO 1 I=1,N
      EI=1.0*I*LENGTH
      EIM=EI-LENGTH
    1 MT(I)=WLOOSE(NF,EPS,X,EI)-WLOOSE(NF,EPS,X,EIM)
      K=0
      DO 2 I=1,NF
      IF(XP(I).GT.0.51) GOTO 3
      GOTO 2
    3 K=K+1
      MR(K)=INT(EPS(I)/LENGTH+.5)
    2 CONTINUE
      CALL COUNT(K,N)
      DO 5 I=1,N
    5 MT(I)=MT(I)+MT(I-1)
      DO 4 I=0,N
    4 MW(I)=MT(I)
      RETURN
      END
      
      
      
 c=================================================================     
      SUBROUTINE COUNT(K,M)
C*********************************************************************
C BEYER-SWINEHART-count
C This subroutine counts the number of complexions for an ensemble of
C k harmonic oscillators up to an energy of m*deltaE; k, m, and r as
C well as the starting vector t (and of course deltaE) have to be 
C specified in the calling routine.
C
C ref.: S.E.STEIN, B.S.RABINOVITCH: J.Chem.Phys. 58, 2438 (1973)
C*********************************************************************
      COMMON/C/ T(0:100005)
      COMMON/D/ R(200)
      INTEGER R
      DOUBLE PRECISION T
      DO 1 I=1,K
      DO 1 J=R(I),M
    1 T(J)=T(J)+T(J-R(I))
      RETURN
      END
      
      
c=================================================================      
      SUBROUTINE ETERAT(DMORSE,EZP,DEZ,ALBE,BE,A1,A2,J,ENULLJ)
C********************************************************************
C This subroutine estimates by an iteration procedure the J-dependent
C threshold energy E0(J) with a MORSE type radial part. If enullj=-1
C then the molecule is in a rotationally repulsive state for the J 
C under consideration.
C********************************************************************
C dmorse: dissociation energy of the MORSE-potential
C ezp: zero-point energy of the reaction products
C dez:ezn-ezp-erc/2
C albe: alpha/beta
C be: mean of the two smallest rotational constants of the reactant
C a1, a2: centrifugal parameters (see ref.)
C j: rotational quantum number
C enullj: E0(J)
C
C ref.: J.TROE, J.Chem.Phys. 75, 226 (1981)
C*******************************************************************
C znew: starting parameter for the iteration, should be as large as
C       possible, restriction: the compiler must be able to treat
C       exp(-znew)
C
      B=DEZ/DMORSE
      ZNEW=85.
      IF(J)1004,1005,1004
 1005 ZOLD=ZNEW
      ZNEW=LOG(2.*(1.-EXP(-ZOLD))/(B*ALBE*EXP(-ALBE*ZOLD)))
      IF(ZNEW.GT.ZOLD) THEN
      ENULLJ=DMORSE+EZP
      RETURN
      ELSE
      TOL=ABS(ZNEW-ZOLD)
      IF(TOL.LE..001) GOTO 1002
      GOTO 1005
      ENDIF
 1004 A=BE*J*(J+1)/DMORSE
 1001 ZOLD=ZNEW
      ZNEW=-LOG(A*(A1+2.*A2*ZOLD)/(2.*(1.-EXP(-ZOLD))*(1.+A1*ZOLD
     *+A2*ZOLD*ZOLD)*(1.+A1*ZOLD+A2*ZOLD*ZOLD))+
     *B*ALBE*EXP(-ALBE*ZOLD)/(2.*(1.-EXP(-ZOLD))))
      IF(ZNEW.LT.0.) GOTO 1003
      TOL=ABS(ZNEW-ZOLD)
      IF(TOL.LE..001) GOTO 1002
      GOTO 1001
 1002 ENULLJ=(1.-EXP(-ZNEW))**2+BE*J*(J+1)/(DMORSE*(1.+A1*ZNEW+
     *A2*ZNEW*ZNEW))+B*EXP(-ALBE*ZNEW)
      ENULLJ=ENULLJ*DMORSE+EZP
      RETURN
 1003 ENULLJ=-1.
      RETURN
      END

      
      
      
c=================================================================      
      SUBROUTINE SPOL(ALBE,DMORSE)
C*******************************************************************
C This subroutine interpolates between reactant and product 
C eigenvalues.
C Reactant: EPSE,XE
C Channel: EPSTS,XTS
C Product: EPSP,XP
C [Ref.: J. TROE, JPC 79, 6017(1983)]
C*******************************************************************
      COMMON/SPOLL/NFG,EPSE(110),EPSP(110),XE(110),XP(110),
     *             EPSTS(110),XTS(110)
      DO 1 I=1,NFG
      IF(XE(I)-XP(I))3,2,3
    2 C3=4.-1.29*LOG(EPSE(I)/DMORSE)
      EPSTS(I)=EPSP(I)+(EPSE(I)-EPSP(I))*EXP(-C3*ALBE)
      XTS(I)=XE(I)
      GOTO 1
    3 C2=1.24+55.*EPSP(I)/EPSE(I)
      C3=4.-1.29*LOG(EPSE(I)/DMORSE)
      C4=2.8-5.19*LOG(EPSE(I)/DMORSE)
      EN=2.25+.005*EPSE(I)/EPSP(I)
      Y=C2*ALBE
      CALBE=C3*ALBE+C4*ALBE*ALBE*ALBE*ALBE
      YN=EXP(-Y-Y**EN)
      EPSTS(I)=EPSP(I)+(EPSE(I)-EPSP(I))*EXP(-CALBE)
      XTS(I)=XE(I)*YN+XP(I)*(1.-YN)**EN
    1 CONTINUE
      RETURN
      END
      
      
      
c=================================================================      
      SUBROUTINE WCOUNT(KZP,NCE,EMAX,LENGTH,J,B1,B2,NVIB1,NVIB2,NY1,
     *NY2,NROTI1,NROTI2)
C**********************************************************************
C This subroutine calculates the overall sum of states by convolution
C of Wl(E,J) with the vibrational degrees of freedom of the fragments
C via the Beyer-Swinehart algorithm followed by the convolution with
C eventually existing free internal rotors of the fragments.
C**********************************************************************
      REAL LENGTH,NY1(100),NY2(100),NY(200)
      DOUBLE PRECISION MT,MW
      COMMON/WCOUN/ MW(0:100005)
      COMMON/C/ MT(0:100005)
      COMMON/D/ MR(200)
      COMMON/ROUT/ RHOIR(0:100005)
      IF(KZP.EQ.1) GOTO 1
      IF(KZP.EQ.2) GOTO 2
      IF(KZP.EQ.3) GOTO 3
      IF(KZP.EQ.4) GOTO 4
      IF(KZP.EQ.5) GOTO 5
    1 CALL WLLA(EMAX,LENGTH,J,B1)
      GOTO 6
    2 CALL WLSA(EMAX,LENGTH,J,B1)
      GOTO 6
    3 CALL WLLL(NCE,EMAX,LENGTH,J,B1,B2)
      GOTO 6
    4 CALL WLSL(NCE,EMAX,LENGTH,J,B1,B2)
      GOTO 6
    5 CALL WLSS(NCE,EMAX,LENGTH,J,B1,B2)
    6 NVIBG=NVIB1+NVIB2
      DO 7 I=1,NVIB1
    7 NY(I)=NY1(I)
      DO 8 I=NVIB1+1,NVIBG
    8 NY(I)=NY2(I-NVIB1)
      DO 9 I=1,NVIBG
    9 MR(I)=INT(NY(I)/LENGTH+.5)
      N=INT(EMAX/LENGTH+.5)
      CALL COUNT(NVIBG,N)
      DO 10 I=1,N
   10 MT(I)=MT(I)+MT(I-1)
      IF(NROTI1.EQ.0.AND.NROTI2.EQ.0) GOTO13
      CALL RHOIRO(N,LENGTH)
      MW(0)=1.
      DO 12 I=1,N
      MW(I)=0.
      DO 11 L=0,I
   11 MW(I)=MW(I)+MT(L)*RHOIR(I-L)
   12 MW(I)=MW(I)*LENGTH
      RETURN
   13 DO 14 I=0,N
   14 MW(I)=MT(I)
      RETURN
      END
      
      
      
c=================================================================      
      SUBROUTINE WLLA(AEMAX,LENGTH,J,B)
C**********************************************************************
C This subroutine calculates Wl(E,J) for systems linear/atom and
C creates the starting vector for the Beyer-Swinehart count.
C**********************************************************************
      DIMENSION MT(0:100005)
      COMMON/C/ MT
      REAL LENGTH
      DOUBLE PRECISION MT
      N=INT(AEMAX/LENGTH+.5)
      MT(0)=1.
      DO 1 I=1,N
      E=REAL(I*LENGTH)
      EM=E-LENGTH
    1 MT(I)=WLLIAT(E,J,B)-WLLIAT(EM,J,B)
      RETURN
      END
      
      
c=================================================================      
      SUBROUTINE WLSA(AEMAX,LENGTH,J,B)
C**********************************************************************
C This subroutine calculates Wl(E,J) for systems spherical top/atom and
C creates the starting vector for the Beyer-Swinehart count.
C**********************************************************************
      DIMENSION MT(0:100005)
      COMMON/C/ MT
      REAL LENGTH
      DOUBLE PRECISION MT
      N=INT(AEMAX/LENGTH+.5)
      MT(0)=1.
      DO 1 I=1,N
      E=REAL(I*LENGTH)
      EM=E-LENGTH
    1 MT(I)=WLSTAT(E,J,B)-WLSTAT(EM,J,B)
      RETURN
      END
      
      
c=================================================================      
      SUBROUTINE WLLL(NCE,AEMAX,LENGTH,JG,B1,B2)
C**********************************************************************
C This subroutine estimates Wl(E,J) for systems linear/linear and
C creates the starting vector for the Beyer-Swinehart count.
C**********************************************************************
      DIMENSION MT(0:100005)
      COMMON/C/ MT
      REAL LENGTH
      DOUBLE PRECISION MT
      N=INT(AEMAX/LENGTH+.5)
      MT(0)=1.
      IF(NCE)6,6,7
    6 NSCH=0
      DO 1 I=1,N
      E=REAL(I*LENGTH)
      EM=E-LENGTH
      IF(NSCH)2,2,3
    2 EXACT=WLLILI(E,JG,B1,B2)
      ORM=WLHILL(E,B1,B2)
      ARG=(2*JG+1)*WLLOLL(E,B1,B2)/ORM
      CLASS=ORM*POLAT(ARG)
      ABW=ABS(EXACT-CLASS)/EXACT*100.
      IF(ABW.LE.2.) GOTO4
      GOTO5
    4 NSCH=1
    5 MT(I)=EXACT-WLLILI(EM,JG,B1,B2)
      GOTO1
    3 ORM=WLHILL(E,B1,B2)
      ARG=(2*JG+1)*WLLOLL(E,B1,B2)/ORM
      CLASS=ORM*POLAT(ARG)
      ORM=WLHILL(EM,B1,B2)
      ARG=(2*JG+1)*WLLOLL(EM,B1,B2)/ORM
      CLASSN=ORM*POLAT(ARG)
      MT(I)=CLASS-CLASSN
    1 CONTINUE
      RETURN
    7 DO 8 I=1,N
      E=REAL(I*LENGTH)
      EM=E-LENGTH  
    8 MT(I)=WLLILI(E,JG,B1,B2)-WLLILI(EM,JG,B1,B2)
      RETURN
      END
      
      
c=================================================================     
      SUBROUTINE WLSL(NCE,AEMAX,LENGTH,JG,BST,BLI)
C**********************************************************************
C This subroutine estimates Wl(E,J) for systems spherical top/linear
C and creates the starting vector for the Beyer-Swinehart count.
C**********************************************************************
      DIMENSION MT(0:100005)
      COMMON/C/ MT
      REAL LENGTH
      DOUBLE PRECISION MT
      N=INT(AEMAX/LENGTH+.5)
      MT(0)=1.
      IF(NCE)6,6,7
    6 NSCH=0
      DO 1 I=1,N
      E=REAL(I*LENGTH)
      EM=E-LENGTH
      IF(NSCH)2,2,3
    2 EXACT=WLSTLI(E,JG,BST,BLI)
      ORM=WLHISL(E,BST,BLI)
      ARG=(2*JG+1)*WLLOSL(E,BST,BLI)/ORM
      CLASS=ORM*POLAT(ARG)
      ABW=ABS(EXACT-CLASS)/EXACT*100.
      IF(ABW.LE.2.) GOTO4
      GOTO5
    4 NSCH=1
    5 MT(I)=EXACT-WLSTLI(EM,JG,BST,BLI)
      GOTO1
    3 ORM=WLHISL(E,BST,BLI)
      ARG=(2*JG+1)*WLLOSL(E,BST,BLI)/ORM
      CLASS=ORM*POLAT(ARG)
      ORM=WLHISL(EM,BST,BLI)
      ARG=(2*JG+1)*WLLOSL(EM,BST,BLI)/ORM
      CLASSN=ORM*POLAT(ARG)
      MT(I)=CLASS-CLASSN
    1 CONTINUE
      RETURN
    7 DO 8 I=1,N
      E=REAL(I*LENGTH)
      EM=E-LENGTH  
    8 MT(I)=WLSTLI(E,JG,BST,BLI)-WLSTLI(EM,JG,BST,BLI)
      RETURN
      END
      
      
c=================================================================      
      SUBROUTINE WLSS(NCE,AEMAX,LENGTH,JG,B1,B2)
C**********************************************************************
C This subroutine estimates Wl(E,J) for systems spherical top/spherical
C top and creates the starting vector for the Beyer-Swinehart count.
C**********************************************************************
      DIMENSION MT(0:100005)
      COMMON/C/ MT
      REAL LENGTH
      DOUBLE PRECISION MT
      N=INT(AEMAX/LENGTH+.5)
      MT(0)=1.
      IF(NCE)6,6,7
    6 NSCH=0
      DO 1 I=1,N
      E=REAL(I*LENGTH)
      EM=E-LENGTH
      IF(NSCH)2,2,3
    2 EXACT=WLSTST(E,JG,B1,B2)
      ORM=WLHISS(E,B1,B2)
      ARG=(2*JG+1)*WLLOSS(E,B1,B2)/ORM
      CLASS=ORM*POLAT(ARG)
      ABW=ABS(EXACT-CLASS)/EXACT*100.
      IF(ABW.LE.2.) GOTO4
      GOTO5
    4 NSCH=1
    5 MT(I)=EXACT-WLSTST(EM,JG,B1,B2)
      GOTO1
    3 ORM=WLHISS(E,B1,B2)
      ARG=(2*JG+1)*WLLOSS(E,B1,B2)/ORM
      CLASS=ORM*POLAT(ARG)
      ORM=WLHISS(EM,B1,B2)
      ARG=(2*JG+1)*WLLOSS(EM,B1,B2)/ORM
      CLASSN=ORM*POLAT(ARG)
      MT(I)=CLASS-CLASSN
    1 CONTINUE
      RETURN
    7 DO 8 I=1,N
      E=REAL(I*LENGTH)
      EM=E-LENGTH  
    8 MT(I)=WLSTST(E,JG,B1,B2)-WLSTST(EM,JG,B1,B2)
      RETURN
      END
      
      
      
c=================================================================      
      SUBROUTINE RHOIRO(N,LENGTH)
C***********************************************************************
C This function calculates the classical density of states of the
C internal rotations of the fragments.
C***********************************************************************
      REAL LENGTH
      DOUBLE PRECISION DGAMMA
      COMMON/RHOI/ NROTI1,NROTI2,AIR1(10),AIR2(10)
      COMMON/ROUT/ RHOIR(0:100005)
      R=REAL(NROTI1+NROTI2)
      RHOIR(0)=0.
      SQRB=1.
      DO 1 I=1,NROTI1
    1 SQRB=SQRB*SQRT(AIR1(I))
      DO 2 I=1,NROTI2
    2 SQRB=SQRB*SQRT(AIR2(I))
      GD=R/2.-1.
      DO 3 I=1,N
      E=I*LENGTH
    3 RHOIR(I)=1.7725**R/(DGAMMA(DBLE(R/2.))*SQRB)*E**GD
      RETURN
      END
